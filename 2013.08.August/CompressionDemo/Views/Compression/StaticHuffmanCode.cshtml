@{
    ViewBag.Title = "Static Huffman Code";
    ViewBag.SelectedNav = "Compression";
}

<div class="container-fluid">
    <div class="row-fluid">
        @Html.Partial("_sidebar")

        <div class="span9">
            <div class="hero-unit">
                <h1>@ViewBag.Title</h1>
            </div>
            <div class="row-fluid fuelux">
                <div class="well">
                    <div id="MyWizard" class="wizard">
                        <ul class="steps">
                            <li data-target="#step1" class="active"><span class="badge badge-info">1</span>Step 1<span class="chevron"></span></li>
                            <li data-target="#step2"><span class="badge">2</span>Step 2<span class="chevron"></span></li>
                            <li data-target="#step3"><span class="badge">3</span>Step 3<span class="chevron"></span></li>
                            <li data-target="#step4"><span class="badge">4</span>Step 4<span class="chevron"></span></li>
                            <li data-target="#step5"><span class="badge">5</span>Step 5<span class="chevron"></span></li>
                        </ul>
                    </div>
                    <div class="step-content">
                        <div class="step-pane active" id="step1">
                            <h2>Enter text</h2>
                            Enter text that you would like to compress<br>
                            <input type="text" id="sampleText" value="bananas" /><br>
                            Click 'Next' to continue.
                        </div>
                        <div class="step-pane" id="step2">
                            <h2>Build the frequency table</h2>
                            You first need to parse the text to generate a frequency table.<br>
                            <button class="btn btn-success" id="next-step2">Step <i class="icon-forward icon-white"></i></button>
                            <button class="btn btn-info" id="next-skip2">Skip <i class="icon-play icon-white"></i></button>
                            <div id="container-step2"></div>
                        </div>
                        <div class="step-pane" id="step3">
                            <h2>Build the Huffman tree</h2>
                            Sort the frequency table in descending order and start building tree from lowest frequency.<br>
                            <button class="btn btn-success" id="next-step3">Step <i class="icon-forward icon-white"></i></button>
                            <button class="btn btn-info" id="next-skip3">Skip <i class="icon-play icon-white"></i></button>
                            <div id="container-step3"></div>
                        </div>
                        <div class="step-pane" id="step4">
                            <h2>Time to build our Huffman code.</h2>
                            Place a 0 on all left branches and a 1 for right branches, then read the code for each letter starting at the root.<br>
                        <button class="btn btn-success" id="next-step4">Step <i class="icon-forward icon-white"></i></button>
                            <button class="btn btn-info" id="next-skip4">Skip <i class="icon-play icon-white"></i></button>
                            <div id="container-step4"></div>
                        </div>
                        <div class="step-pane" id="step5">
                            <h2>Done</h2>
                            Replace each letter with its corresponding Huffman code.<br>
                        <button class="btn btn-success" id="next-step5">Step <i class="icon-forward icon-white"></i></button>
                            <button class="btn btn-info" id="next-skip5">Skip <i class="icon-play icon-white"></i></button>
                            <div id="container-step5"></div>
                        </div>
                    </div>
                    <br>
                    <input type="button" class="btn" id="btnWizardPrev" value="Back">
                    <input type="button" class="btn btn-primary" id="btnWizardNext" value="Next">
                </div>
                <!-- /well -->
            </div>
        </div>
    </div>
</div>

@section Scripts {
    @Scripts.Render("~/bundles/fuelux")
    @Scripts.Render("~/bundles/demo")
<script defer="defer">
    $(document).ready(function () {
        $('#MyWizard').on('change', function (e, data) {
            console.log('change');
            if (data.step === 1 && data.direction === 'next') {
                window.staticHuffmanCode.frequencyTable.init({ container: 'container-step2', text: document.getElementById('sampleText').value, height: 450 });
                document.getElementById('btnWizardNext').classList.add('hidden');
            } else if (data.step === 2 && data.direction === 'next') {
                window.staticHuffmanCode.huffmanTree.init(window.staticHuffmanCode.frequencyTable.context, { container: 'container-step3', height: 600, width: 900 });
                document.getElementById('btnWizardNext').classList.add('hidden');
            } else if (data.step === 3 && data.direction === 'next') {
                window.staticHuffmanCode.huffmanCode.init(window.staticHuffmanCode.frequencyTable.context, { container: 'container-step4', height: 600, width: 900 });
                document.getElementById('btnWizardNext').classList.add('hidden');
            } else if (data.step === 4 && data.direction === 'next') {
                window.staticHuffmanCode.encode.init(window.staticHuffmanCode.frequencyTable.context, { container: 'container-step5', height: 450, width: 900 });
                document.getElementById('btnWizardNext').classList.add('hidden');
            }
            
            if (data.direction === 'prev') {
                document.getElementById('btnWizardNext').classList.remove('hidden');
            }
        });
        $('#MyWizard').on('changed', function (e, data) {
            console.log('changed');
        });
        $('#MyWizard').on('finished', function (e, data) {
            console.log('finished');
        });
        $('#btnWizardPrev').on('click', function () {
            $('#MyWizard').wizard('previous');
        });
        $('#btnWizardNext').on('click', function () {
            $('#MyWizard').wizard('next', 'foo');
        });
        $('#btnWizardStep').on('click', function () {
            var item = $('#MyWizard').wizard('selectedItem');
            console.log(item.step);
        });
        $('#MyWizard').on('stepclick', function (e, data) {
            console.log('step' + data.step + ' clicked');
            if (data.step === 1) {
                // return e.preventDefault();
            }
        });
    });

    document.getElementById('next-step2').addEventListener('click', function () {
        window.staticHuffmanCode.frequencyTable.next();
    });

    document.getElementById('next-skip2').addEventListener('click', function () {
        window.staticHuffmanCode.frequencyTable.continue();
    });

    document.getElementById('next-step3').addEventListener('click', function () {
        window.staticHuffmanCode.huffmanTree.next();
    });

    document.getElementById('next-skip3').addEventListener('click', function () {
        window.staticHuffmanCode.huffmanTree.continue();
    });

    document.getElementById('next-step4').addEventListener('click', function () {
        window.staticHuffmanCode.huffmanCode.next();
    });

    document.getElementById('next-skip4').addEventListener('click', function () {
        window.staticHuffmanCode.huffmanCode.continue();
    });

    document.getElementById('next-step5').addEventListener('click', function () {
        window.staticHuffmanCode.encode.next();
    });

    document.getElementById('next-skip5').addEventListener('click', function () {
        window.staticHuffmanCode.encode.continue();
    });
    </script>

    <script defer="defer">
        (function (staticHuffmanCode, $, undefined) {
            (function (frequencyTable, $, undefined) {
                var self = frequencyTable;
                var cursor;

                frequencyTable.init = function (opts) {
                    self.tableRows = {};
                    opts = $.extend({}, { height: 200, width: 578, container: 'container-frequencyTable' }, opts);
                    self.stage = new Kinetic.Stage({
                        container: opts.container,
                        width: opts.width,
                        height: opts.height
                    });

                    self.context = new Compression.Demo.StaticHuffmanCode.Context({ text: opts.text });

                    self.text = opts.text;
                    self.textLayer = new Kinetic.Layer();
                    self.tableLayer = new Kinetic.Layer();

                    // add the layer to the stage
                    self.stage.add(self.textLayer);
                    self.stage.add(self.tableLayer);
                    self.stage.hide();
                    self.draw();
                };

                frequencyTable.draw = function () {
                    //self.stage.hide();
                    //self.textLayer.clear();
                    //self.tableLayer.clear();

                    originalText = new Kinetic.Text({
                        x: self.stage.getWidth() / 2,
                        y: 60,
                        text: self.text,
                        fontSize: 24,
                        fontFamily: 'Calibri',
                        fill: 'green'
                    });

                    // to align text in the middle of the screen, we can set the
                    // shape offset to the center of the text shape after instantiating it
                    originalText.setOffset({
                        x: originalText.getWidth() / 2
                    });

                    // add the shape to the layer
                    self.textLayer.add(originalText);

                    if (self.context && self.context.position >= 0) {
                        if (!cursor) {
                            cursor = new Kinetic.Rect({
                                x: originalText.getX() - originalText.getOffsetX() - 2,
                                y: originalText.getY() - originalText.getOffsetY(),
                                width: originalText.getWidth() / originalText.getText().length + 3,
                                height: originalText.getTextHeight() + 3,
                                stroke: 'red',
                                strokeWidth: 2
                            });

                            self.setCursorWidth(cursor, self.context.text[self.context.position]);
                            self.textLayer.add(cursor);
                            self.animateLetterToTable(cursor);
                        } else {
                            var tween = new Kinetic.Tween({
                                node: cursor,
                                x: cursor.getX() + cursor.getWidth() - 2,
                                y: originalText.getY() - 3,
                                easing: Kinetic.Easings.EaseInOut,
                                duration: 1,
                                onFinish: function () {
                                    self.setCursorWidth(cursor, self.context.text[self.context.position]);
                                    self.animateLetterToTable(cursor);
                                }
                            });

                            tween.play();
                        }
                    }

                    self.stage.show();
                    self.textLayer.draw();
                };

                frequencyTable.animateLetterToTable = function (cursor) {
                    var context = self.context;
                    var symbol = self.context.text[self.context.position]
                    var run = new Kinetic.Text({
                        x: cursor.getX(),
                        y: 60,
                        text: symbol,
                        fontSize: 24,
                        fontFamily: 'Calibri',
                        fill: 'green'
                    });

                    self.textLayer.add(run);
                    self.textLayer.draw();

                    // find where in table letter is
                    var count = 0
                    $.each(self.tableRows, function () { count++; });
                    var position = $.extend({}, { x: 20, y: 20 + (44 * count) }, self.tableRows[symbol]);

                    // animate letter moving to table
                    var tween = new Kinetic.Tween({
                        node: run,
                        x: position.x + 10,
                        y: position.y + 10,
                        easing: Kinetic.Easings.EaseInOut,
                        duration: 2,
                        onFinish: function () {
                            run.destroy();
                            self.drawTable();
                            document.getElementById('next-step2').disabled = context.complete;
                            if (self.context.complete) {
                                cursor.destroy();
                                self.textLayer.destroy();
                                document.getElementById('btnWizardNext').classList.remove('hidden');
                            }
                        }
                    });

                    tween.play();
                };

                frequencyTable.drawTable = function () {
                    var tween;
                    var xOffset = 20;
                    var yOffset = 20;
                    var table = self.context.table;

                    self.tableLayer.removeChildren();

                    for (var symbol in table) {
                        if (!self.tableRows[symbol]) {
                            self.tableRows[symbol] = { x: xOffset, y: yOffset };
                        }

                        var cell1Text = new Kinetic.Text({
                            x: xOffset,
                            y: yOffset,
                            padding: 10,
                            width: 35,
                            text: table[symbol].symbol,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });

                        var cell2Text = new Kinetic.Text({
                            x: cell1Text.getX() + cell1Text.getWidth(),
                            y: yOffset,
                            padding: 10,
                            width: 35,
                            text: table[symbol].count,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });
                        
                        var row = new Kinetic.Rect({
                            x: cell1Text.getX(),
                            y: cell1Text.getY(),
                            stroke: 'black',
                            strokeWidth: 3,
                            width: cell1Text.getWidth() + cell2Text.getWidth(),
                            height: cell1Text.getHeight()
                        });

                        var divider = new Kinetic.Line({
                            points: [cell1Text.getX() + cell1Text.getWidth(), cell1Text.getY(), cell1Text.getX() + cell1Text.getWidth(), yOffset + cell1Text.getHeight()],
                            stroke: 'black',
                            strokeWidth: 3
                        });

                        yOffset += row.getHeight();

                        self.tableLayer.add(row);
                        self.tableLayer.add(divider);
                        self.tableLayer.add(cell1Text);
                        self.tableLayer.add(cell2Text);
                        
                        if (self.context.symbol == symbol) {
                            self.tableLayer.add(row.clone());
                            row.setFill('#FF6');

                            tween = new Kinetic.Tween({
                                node: row,
                                opacity: 0,
                                duration: 2,
                                easing: Kinetic.Easings.EaseInOut
                            });
                        }
                    }

                    self.tableLayer.draw();

                    if (tween)
                        tween.play();
                };

                frequencyTable.next = function () {
                    document.getElementById('next-step2').disabled = true;
                    Compression.Demo.StaticHuffmanCode.buildFrequencyTable(self.context);
                    frequencyTable.draw();
                };

                frequencyTable.continue = function () {
                    document.getElementById('next-step2').disabled = true;
                    self.context.pause = false;
                    Compression.Demo.StaticHuffmanCode.buildFrequencyTable(self.context);
                    frequencyTable.drawTable();
                    self.textLayer.destroy();
                    document.getElementById('btnWizardNext').classList.remove('hidden');
                };

                frequencyTable.setCursorWidth = function (cursor, text) {
                    cursor.setWidth(staticHuffmanCode.getTextWidth({ text: text }) + 2);
                };
            })(staticHuffmanCode.frequencyTable = staticHuffmanCode.frequncyTable || {}, $);


            (function (huffmanTree, $, undefined) {
                var self = huffmanTree;
                var context;
                var tableLayer;
                var treeLayer;
                var stage;
                var tableRows;
                var treeDepth;

                self.init = function (ctxt, opts) {
                    context = ctxt;
                    context.pause = true;
                    
                    opts = $.extend({}, { height: 200, width: 578, container: 'container-buildTree' }, opts);

                    tableRows = {};

                    stage = new Kinetic.Stage({
                        container: opts.container,
                        width: opts.width,
                        height: opts.height
                    });

                    Compression.Demo.StaticHuffmanCode.buildQueue(context);

                    tableLayer = new Kinetic.Layer();
                    treeLayer = new Kinetic.Layer();

                    // add the layer to the stage
                    stage.add(treeLayer);
                    stage.add(tableLayer);
                    //stage.hide();
                    //self.draw();

                    self.draw();
                }

                self.draw = function () {
                    self.drawTree();
                    self.drawTable();

                    complete();
                };

                var complete = function () {
                    document.getElementById('next-step3').disabled = context.complete;
                    if (context.complete) {
                        tableLayer.destroy();
                        document.getElementById('btnWizardNext').classList.remove('hidden');
                    }
                }

                var recurseTree = function (node, depth, index) {
                    var leftNode;
                    var rightNode;

                    if (treeDepth < depth)
                        treeDepth = depth;

                    if (node.left) {
                        leftNode = recurseTree(node.left, depth + 1, index * 2 - 1);
                    }

                    if (node.right) {
                        rightNode = recurseTree(node.right, depth + 1, index * 2);
                    }

                    return { depth: depth, index: index, symbol: node.symbol, count: node.count, left: leftNode, right: rightNode };
                }

                var nodePosition = function (node) {
                    var canvasWidth = (stage.getWidth() - 200);
                    var canvasHeight = (stage.getHeight() - 100);

                    x = 200 + node.index * Math.max(60, canvasWidth / (Math.pow(2, node.depth) + 1));
                    y = 50 + node.depth * Math.max(60, Math.min(100, canvasHeight / treeDepth));

                    return { x: x, y: y };
                }

                var drawNode = function (node) {
                    var pos = nodePosition(node);

                    var circle = new Kinetic.Circle({
                        x: pos.x,
                        y: pos.y,
                        radius: 30,
                        stroke: 'black',
                        strokeWidth: 3,
                        fill: 'white'
                    });

                    var count = new Kinetic.Text({
                        x: pos.x - 6,
                        y: pos.y - 10,
                        text: node.count,
                        width: 30,
                        stroke: 'green',
                        strokeWidth: 3,
                        fontSize: 24,
                        fontFamily: 'Calibri',
                        zindex: 2
                    });

                    treeLayer.add(circle);
                    treeLayer.add(count);

                    if (!node.left && !node.right) {
                        var symbol = new Kinetic.Text({
                            x: pos.x - 6,
                            y: pos.y + 30,
                            text: node.symbol,
                            width: 35,
                            stroke: 'black',
                            fontSize: 24,
                            fontFamily: 'Calibri',
                        });

                        treeLayer.add(symbol);
                    }


                    if (node.left) {
                        var child = drawNode(node.left);

                        var line = new Kinetic.Line({
                            points: [pos.x, pos.y, child.getX(), child.getY()],
                            stroke: 'black',
                            strokeWidth: 3
                        });

                        treeLayer.add(line);
                        line.moveToBottom();
                    }

                    if (node.right) {
                        var child = drawNode(node.right);

                        var line = new Kinetic.Line({
                            points: [pos.x, pos.y, child.getX(), child.getY()],
                            stroke: 'black',
                            strokeWidth: 3
                        });

                        treeLayer.add(line);
                        line.moveToBottom();
                    }

                    circle.moveToTop();
                    count.moveToTop();

                    return circle;
                }

                self.drawTree = function () {
                    var queue = context.queue;
                    var tree = [];
                    var index = 1;

                    treeDepth = 0;

                    treeLayer.removeChildren();

                    for (var i = 0 ; i < queue.length; i++) {
                        var node = queue[i];

                        if (node.left && node.right) {
                            var node = recurseTree(node, 0, index);
                            tree.push(node);
                            index++;
                        }
                    }

                    for (var i = 0 ; i < tree.length; i++) {
                        drawNode(tree[i]);
                    }

                    treeLayer.draw();
                }

                self.drawTable = function () {
                    var queue = context.queue;
                    var xOffset = 20;
                    var yOffset = 20;
                    var maxWidth = 35;
                    var padding = 20;

                    tableLayer.removeChildren();


                    for (var i = 0; i < queue.length; i++) {
                        var width = staticHuffmanCode.getTextWidth({ text: queue[i].symbol }) + padding;

                        if (maxWidth < width)
                            maxWidth = width;
                    }

                    for (var i = 0; i < queue.length; i++) {
                        var node = queue[i];

                        if (!tableRows[node.symbol]) {
                            tableRows[node.symbol] = { x: xOffset, y: yOffset };
                        }

                        var cell1Text = new Kinetic.Text({
                            x: xOffset,
                            y: yOffset,
                            padding: 10,
                            width: maxWidth,
                            text: node.symbol,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });

                        var cell2Text = new Kinetic.Text({
                            x: cell1Text.getX() + cell1Text.getWidth(),
                            y: yOffset,
                            padding: 10,
                            width: 35,
                            text: node.count,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });

                        var row = new Kinetic.Rect({
                            x: cell1Text.getX(),
                            y: cell1Text.getY(),
                            stroke: 'black',
                            strokeWidth: 3,
                            width: cell1Text.getWidth() + cell2Text.getWidth(),
                            height: cell1Text.getHeight()
                        });

                        var divider = new Kinetic.Line({
                            points: [cell1Text.getX() + cell1Text.getWidth(), cell1Text.getY(), cell1Text.getX() + cell1Text.getWidth(), yOffset + cell1Text.getHeight()],
                            stroke: 'black',
                            strokeWidth: 3
                        });

                        yOffset += row.getHeight();

                        tableLayer.add(row);
                        tableLayer.add(divider);
                        tableLayer.add(cell1Text);
                        tableLayer.add(cell2Text);
                    }

                    tableLayer.draw();
                };

                self.next = function () {
                    document.getElementById('next-step3').disabled = true;
                    Compression.Demo.StaticHuffmanCode.buildTree(context);
                    self.draw();
                };

                self.continue = function () {
                    document.getElementById('next-step3').disabled = true;
                    context.pause = false;
                    Compression.Demo.StaticHuffmanCode.buildTree(context);
                    self.draw();
                };



            })(staticHuffmanCode.huffmanTree = staticHuffmanCode.huffmanTree || {}, $);

            (function (huffmanCode, $, undefined) {
                var self = huffmanCode;
                var context;
                var tableLayer;
                var treeLayer;
                var stage;
                var tableRows;
                var treeDepth;
                var codeQueue;
                var currCode;

                self.init = function (ctxt, opts) {
                    context = ctxt;
                    context.pause = true;

                    opts = $.extend({}, { height: 200, width: 578, container: 'container-buildCode'}, opts);

                    tableRows = {};
                    codeQueue = [];

                    for(var symbol in context.table)
                        codeQueue.push(symbol);

                    stage = new Kinetic.Stage({
                        container: opts.container,
                        width: opts.width,
                        height: opts.height
                    });

                    Compression.Demo.StaticHuffmanCode.buildCodes(context);

                    tableLayer = new Kinetic.Layer();
                    treeLayer = new Kinetic.Layer();

                    // add the layer to the stage
                    stage.add(treeLayer);
                    stage.add(tableLayer);
                    //stage.hide();
                    //self.draw();

                    self.draw();
                }

                self.draw = function () {
                    self.drawTree();
                    self.drawTable();

                    complete();
                };

                var complete = function () {
                    document.getElementById('next-step4').disabled = !codeQueue.length;
                    if (!codeQueue.length) {
                        document.getElementById('btnWizardNext').classList.remove('hidden');
                    }
                }

                var recurseTree = function (node, depth, index) {
                    var leftNode;
                    var rightNode;

                    if (treeDepth < depth)
                        treeDepth = depth;

                    if (node.left) {
                        leftNode = recurseTree(node.left, depth + 1, index * 2 - 1);
                    }

                    if (node.right) {
                        rightNode = recurseTree(node.right, depth + 1, index * 2);
                    }

                    return { depth: depth, index: index, symbol: node.symbol, count: node.count, left: leftNode, right: rightNode };
                }

                var nodePosition = function (node) {
                    var canvasWidth = (stage.getWidth() - 200);
                    var canvasHeight = (stage.getHeight() - 100);

                    x = 200 + node.index * Math.max(60, canvasWidth / (Math.pow(2, node.depth) + 1));
                    y = 50 + node.depth * Math.max(60, Math.min(100, canvasHeight / treeDepth));

                    return { x: x, y: y };
                }

                var drawNode = function (node) {
                    var pos = nodePosition(node);
                    var stroke = node.symbol.indexOf(currCode) >= 0 ? 'red' : 'black';

                    var circle = new Kinetic.Circle({
                        x: pos.x,
                        y: pos.y,
                        radius: 30,
                        stroke: stroke,
                        strokeWidth: 3,
                        fill: 'white'
                    });

                    treeLayer.add(circle);

                    if (!node.left && !node.right) {
                        var symbol = new Kinetic.Text({
                            x: pos.x - 6,
                            y: pos.y + 30,
                            text: node.symbol,
                            width: 35,
                            stroke: stroke,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                        });

                        treeLayer.add(symbol);
                    }


                    if (node.left) {
                        var child = drawNode(node.left);
                        var lineStroke = node.left.symbol.indexOf(currCode) >= 0 ? stroke : 'black';

                        var line = new Kinetic.Line({
                            points: [pos.x, pos.y, child.getX(), child.getY()],
                            stroke: lineStroke,
                            strokeWidth: 3
                        });

                        var code = new Kinetic.Text({
                            x: pos.x - ((pos.x - child.getX()) / 2) - 15,
                            y: pos.y + ((child.getY() - pos.y) / 2) - 20,
                            text: "0",
                            width: 35,
                            stroke: lineStroke,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                        });

                        treeLayer.add(line);
                        treeLayer.add(code);
                        line.moveToBottom();
                    }

                    if (node.right) {
                        var child = drawNode(node.right);
                        var lineStroke = node.right.symbol.indexOf(currCode) >= 0 ? stroke : 'black';

                        var line = new Kinetic.Line({
                            points: [pos.x, pos.y, child.getX(), child.getY()],
                            stroke: lineStroke,
                            strokeWidth: 3
                        });

                        var code = new Kinetic.Text({
                            x: pos.x + ((child.getX() - pos.x) / 2) + 10,
                            y: pos.y + ((child.getY() - pos.y) / 2) - 20,
                            text: "1",
                            width: 35,
                            stroke: lineStroke,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                        });

                        treeLayer.add(line);
                        treeLayer.add(code);
                        line.moveToBottom();
                    }

                    circle.moveToTop();

                    return circle;
                }

                self.drawTree = function () {
                    var queue = context.queue;
                    var tree = [];
                    var index = 1;

                    treeDepth = 0;

                    treeLayer.removeChildren();

                    for (var i = 0 ; i < queue.length; i++) {
                        var node = queue[i];

                        if (node.left && node.right) {
                            var node = recurseTree(node, 0, index);
                            tree.push(node);
                            index++;
                        }
                    }

                    for (var i = 0 ; i < tree.length; i++) {
                        drawNode(tree[i]);
                    }

                    treeLayer.draw();
                }

                self.drawTable = function () {
                    var table = context.table;
                    var xOffset = 20;
                    var yOffset = 20;
                    var maxWidth = 35;
                    var padding = 20;

                    tableLayer.removeChildren();
                    
                    for (var symbol in table) {
                        var node = table[symbol];

                        var cell1Text = new Kinetic.Text({
                            x: xOffset,
                            y: yOffset,
                            padding: 10,
                            width: 35,
                            text: symbol,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });

                        var cell2Text = new Kinetic.Text({
                            x: cell1Text.getX() + cell1Text.getWidth(),
                            y: yOffset,
                            padding: 10,
                            width: 35,
                            text: node.count,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });

                        var cell3Text = new Kinetic.Text({
                            x: cell2Text.getX() + cell2Text.getWidth(),
                            y: yOffset,
                            padding: 10,
                            width: 80,
                            text: node.code,
                            fontSize: 24,
                            fontFamily: 'Calibri',
                            fill: 'black'
                        });

                        var row = new Kinetic.Rect({
                            x: cell1Text.getX(),
                            y: cell1Text.getY(),
                            stroke: 'black',
                            strokeWidth: 3,
                            width: cell1Text.getWidth() + cell2Text.getWidth() + cell3Text.getWidth(),
                            height: cell1Text.getHeight() 
                        });
                        
                        if (symbol == currCode)
                            row.setFill('#FF6');
                        
                        var divider = new Kinetic.Line({
                            points: [cell1Text.getX() + cell1Text.getWidth(), cell1Text.getY(), cell1Text.getX() + cell1Text.getWidth(), yOffset + cell1Text.getHeight()],
                            stroke: 'black',
                            strokeWidth: 3
                        });

                        var divider2 = new Kinetic.Line({
                            points: [cell2Text.getX() + cell2Text.getWidth(), cell2Text.getY(), cell2Text.getX() + cell2Text.getWidth(), yOffset + cell2Text.getHeight()],
                            stroke: 'black',
                            strokeWidth: 3
                        });

                        yOffset += row.getHeight();

                        tableLayer.add(row);
                        tableLayer.add(divider);
                        tableLayer.add(divider2);
                        tableLayer.add(cell1Text);
                        tableLayer.add(cell2Text);
                        tableLayer.add(cell3Text);
                    }

                    tableLayer.draw();
                };

                self.next = function () {
                    getCodes();
                    self.draw();
                };

                self.continue = function () {
                    document.getElementById('next-step4').disabled = true;
                    context.pause = false;
                    getCodes();
                    currCode = null;
                    self.draw();
                };

                var getCodes = function() {
                    while(codeQueue.length) {
                        var symbol = codeQueue.shift();
                        var code = getNextCode(symbol, context.queue[0]);

                        context.table[symbol].code = code;
                        currCode = symbol;

                        if (codeQueue.length && context.pause)
                            return;
                    }
                }

                var getNextCode = function (symbol, node) {
                    if (symbol == node.symbol)
                        return node.code;

                    if (node.left.symbol.indexOf(symbol) >= 0)
                        return getNextCode(symbol, node.left);

                    if (node.right.symbol.indexOf(symbol) >= 0)
                        return getNextCode(symbol, node.right);                    
                }
            })(staticHuffmanCode.huffmanCode = staticHuffmanCode.huffmanCode || {}, $);

            staticHuffmanCode.getTextWidth = function (opts) {
                opts = $.extend({}, { text: '', fontSize: 24, fontFamily: 'Calibri' }, opts);

                var symbol = new Kinetic.Text({
                    text: opts.text,
                    fontSize: opts.fontSize,
                    fontFamily: opts.fontFamily
                });

                return symbol.getTextWidth();
            }
        })(window.staticHuffmanCode = window.staticHuffmanCode || {}, jQuery);

        (function (encode, $, undefined) {
            var self = encode;
            var context;
            var text;
            var cursor;
            var stage;
            var textLayer;
            var tableLayer;
            var state;
            var tableRows;
            var outputText;

            self.init = function (ctxt, opts) {
                tableRows = {};
                context = ctxt;
                context.pause = true;
                state = { symbol: null, position: -1, code: '', output: '' };

                opts = $.extend({}, { height: 200, width: 578, container: 'container-encoding' }, opts);

                stage = new Kinetic.Stage({
                    container: opts.container,
                    width: opts.width,
                    height: opts.height
                });
                
                text = context.text;

                textLayer = new Kinetic.Layer();
                tableLayer = new Kinetic.Layer();

                // add the layer to the stage
                stage.add(textLayer);
                stage.add(tableLayer);
                draw();
            };

            var draw = function () {
                textLayer.removeChildren();

                var titleText1 = new Kinetic.Text({
                    x: 200,
                    y: 20,
                    text: "Original String",
                    fontSize: 28,
                    fontFamily: 'Calibri',
                    fill: 'black'
                });

                var originalText = new Kinetic.Text({
                    x: 200,
                    y: 60,
                    text: text,
                    fontSize: 24,
                    fontFamily: 'Calibri',
                    fill: 'green'
                });

                var titleText2 = new Kinetic.Text({
                    x: 200,
                    y: 100,
                    text: "Encoded String",
                    fontSize: 28,
                    fontFamily: 'Calibri',
                    fill: 'black'
                });

                outputText = new Kinetic.Text({
                    x: 200,
                    y: 130,
                    text: state.output,
                    fontSize: 24,
                    fontFamily: 'Calibri',
                    fill: 'black'
                });

                // to align text in the middle of the screen, we can set the
                // shape offset to the center of the text shape after instantiating it
                /*titleText1.setOffset({
                    x: titleText1.getWidth() / 2
                });

                originalText.setOffset({
                    x: originalText.getWidth() / 2
                });

                titleText2.setOffset({
                    x: titleText2.getWidth() / 2
                });*/
                

                // add the shape to the layer
                textLayer.add(titleText1);
                textLayer.add(originalText);
                textLayer.add(titleText2);
                textLayer.add(outputText);

                if (state.position >= 0) {
                    if (!cursor) {
                        cursor = new Kinetic.Rect({
                            x: originalText.getX() - originalText.getOffsetX() - 2,
                            y: originalText.getY() - originalText.getOffsetY(),
                            width: originalText.getWidth() / originalText.getText().length + 3,
                            height: originalText.getTextHeight() + 3,
                            stroke: 'red',
                            strokeWidth: 2
                        });

                        setCursorWidth(cursor, text[state.position]);
                        textLayer.add(cursor);
                        animateCode();
                    } else {                        
                        textLayer.add(cursor);
                        var tween = new Kinetic.Tween({
                            node: cursor,
                            x: cursor.getX() + cursor.getWidth() - 2,
                            y: originalText.getY() - 3,
                            easing: Kinetic.Easings.EaseInOut,
                            duration: 1,
                            onFinish: function () {
                                setCursorWidth(cursor, text[state.position]);
                                animateCode();
                            }
                        });

                        tween.play();
                    }
                }

                textLayer.draw();
                drawTable();
            };

            var animateCode = function () {
                var context = self.context;
                var code = state.code;
                var position = tableRows[state.symbol];

                var codeText = new Kinetic.Text({
                    x: position.x+10,
                    y: position.y+10,
                    text: code,
                    fontSize: 24,
                    fontFamily: 'Calibri',
                    fill: 'green'
                });

                textLayer.add(codeText);
                codeText.moveToTop();
                textLayer.draw();
                
                // animate letter moving to table
                var tween = new Kinetic.Tween({
                    node: codeText,
                    x: outputText.getX() - outputText.getOffsetX() + outputText.getWidth(),
                    y: outputText.getY(),
                    easing: Kinetic.Easings.EaseInOut,
                    duration: 2,
                    onFinish: function () {
                        codeText.destroy();
                        outputText.setText(state.output + state.code);
                        textLayer.draw();
                        complete();
                    }
                });

                tween.play();
            };

            var drawTable = function () {
                var tween;
                var xOffset = 20;
                var yOffset = 20;
                var table = context.table;

                tableLayer.removeChildren();

                for (var symbol in table) {
                    var cell1Text = new Kinetic.Text({
                        x: xOffset,
                        y: yOffset,
                        padding: 10,
                        width: 35,
                        text: table[symbol].symbol,
                        fontSize: 24,
                        fontFamily: 'Calibri',
                        fill: 'black'
                    });

                    var cell2Text = new Kinetic.Text({
                        x: cell1Text.getX() + cell1Text.getWidth(),
                        y: yOffset,
                        padding: 10,
                        width: 35,
                        text: table[symbol].count,
                        fontSize: 24,
                        fontFamily: 'Calibri',
                        fill: 'black'
                    });

                    var cell3Text = new Kinetic.Text({
                        x: cell2Text.getX() + cell2Text.getWidth(),
                        y: yOffset,
                        padding: 10,
                        width: 80,
                        text: table[symbol].code,
                        fontSize: 24,
                        fontFamily: 'Calibri',
                        fill: 'black'
                    });

                    var row = new Kinetic.Rect({
                        x: cell1Text.getX(),
                        y: cell1Text.getY(),
                        stroke: 'black',
                        strokeWidth: 3,
                        width: cell1Text.getWidth() + cell2Text.getWidth() + cell3Text.getWidth(),
                        height: cell1Text.getHeight()
                    });

                    var divider = new Kinetic.Line({
                        points: [cell2Text.getX(), cell1Text.getY(), cell2Text.getX(), yOffset + cell1Text.getHeight()],
                        stroke: 'black',
                        strokeWidth: 3
                    });

                    var divider2 = new Kinetic.Line({
                        points: [cell3Text.getX(), cell2Text.getY(), cell3Text.getX(), yOffset + cell1Text.getHeight()],
                        stroke: 'black',
                        strokeWidth: 3
                    });

                    tableRows[symbol] = { x: cell3Text.getX(), y: yOffset };

                    yOffset += row.getHeight();

                    tableLayer.add(row);
                    tableLayer.add(divider);
                    tableLayer.add(divider2);
                    tableLayer.add(cell1Text);
                    tableLayer.add(cell2Text);
                    tableLayer.add(cell3Text);
                    /*
                    if (self.context.symbol == symbol) {
                        self.tableLayer.add(row.clone());
                        row.setFill('#FF6');

                        tween = new Kinetic.Tween({
                            node: row,
                            opacity: 0,
                            duration: 2,
                            easing: Kinetic.Easings.EaseInOut
                        });
                    }*/
                }

                tableLayer.draw();

                if (tween)
                    tween.play();
            };

            self.next = function () {
                document.getElementById('next-step5').disabled = true;
                getOutput();
                draw();
            };

            self.continue = function () {
                document.getElementById('next-step5').disabled = true;
                context.pause = false;
                getOutput();
                draw();
                complete();
            };

            var complete = function () {
                document.getElementById('next-step5').disabled = state.position >= context.text.length;
                if (state.position >= context.text.length) {
                    cursor.destroy();

                    var hText = '';
                    var h = 0;
                    var count = 0;
                    for (var symbol in context.table)
                    {
                        var freq = context.table[symbol];

                        if (hText.length)
                            hText = hText + ' + ';

                        hText = hText + ' ' + freq.count + ' * ' + freq.code.length;
                        h = h + freq.count * freq.code.length;
                        count = count + freq.count;
                    }

                    var entropy = new Kinetic.Text({
                        x: 200,
                        y: 180,
                        text: "H = " + hText + ' / ' + count,
                        fontSize: 28,
                        fontFamily: 'Calibri',
                        fill: 'black'
                    });

                    var entropy2 = new Kinetic.Text({
                        x: 200,
                        y: 220,
                        text: "H = " + h / count + ' bits',
                        fontSize: 28,
                        fontFamily: 'Calibri',
                        fill: 'black'
                    });

                    textLayer.add(entropy);
                    textLayer.add(entropy2);
                    textLayer.draw();
                }
            };

            var setCursorWidth = function (cursor, text) {
                cursor.setWidth(staticHuffmanCode.getTextWidth({ text: text }) + 2);
            };

            var getOutput = function () {
                for (state.position++; state.position < text.length; state.position++) {
                    state.symbol = text[state.position];
                    state.output = state.output + state.code;
                    state.code = context.table[state.symbol].code;

                    if (state.position < text.length - 1 && context.pause)
                        return;
                }
            }
        })(staticHuffmanCode.encode = staticHuffmanCode.encode || {}, $);

        $(document).ready(function () {
            window.staticHuffmanCode.frequencyTable.init({ container: 'container-step2' });
        });
    </script>
}